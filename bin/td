#!perl

# DATE
# VERSION

use 5.010001;
# IFUNBUILT
use strict;
use warnings;
# END IFUNBUILT

my %Opts = (
    #input_format => undef,
    output_format => "text",
);
my $Input; # envres
my $Input_Form;
my $SubCmd;
my $Output; # envres

sub parse_cmdline {
    require Getopt::Panjang;

    my $opt_help;
    my %common_opts = (
        'output-format|f=s' => sub {
            my %a = @_;
            $Opts{output_format} = $a{value};
        },
        'version|v' => sub {
            say "tabledata version ", ($main::VERSION // '?');
            exit 0;
        },
        'help|h|?' => sub { $opt_help++ },
    );

    my $res = Getopt::Panjang::get_options(spec => \%common_opts);
    my $remaining_argv = $res->[3]{'func.remaining_argv'};

    $SubCmd = $remaining_argv->[0] // '';
    if ($opt_help) {
        if ($SubCmd eq 'sum') {

        } elsif ($SubCmd ne '') {
            die "Unknown subcommand '$SubCmd'\n";
        } else {
            print <<'_';
Usage:
  tabledata [COMMON_OPTS] <SUBCOMMAND> [SUBCMD_OPTS] < INPUT
  tabledata --version (or -v)
  tabledata --help (or -h, -?)
Common options:
  --output-format=s, -f

Consult manpage/documentation for more details.
_
        }
        exit 0;
    }
}

sub _decode_json {
    require JSON::XS;

    state $json = JSON::XS->new->allow_nonref;
    $json->decode(shift);
}

sub get_input {
    require Data::Check::Structure;

    {
        local $/;
        $Input = _decode_json(~~<>);
    }

    die "Input is not table data\n" unless ref($Input) eq 'ARRAY';

    # give envelope if not enveloped
    unless (@$Input >= 2 && @$Input <= 4 &&
                $Input->[0] =~ /\A[2-5]\d\d\z/ &&
                !ref($Input->[1]) &&
                ref($Input->[2]) eq 'ARRAY'
            ) {
        $Input = [200, "Envelope added by tabledata", $Input];
    }

    # detect table form
    if (ref($Input->[2]) eq 'HASH') {
        $Input_Form = 'hash';
    } elsif (Data::Check::Structure::is_aos($Input->[2])) {
        $Input_Form = 'aos';
    } elsif (Data::Check::Structure::is_aoaos($Input->[2])) {
        $Input_Form = 'aoaos';
    } elsif (Data::Check::Structure::is_aohos($Input->[2])) {
        $Input_Form = 'aohos';
    } else {
        die "Input form is not recognizable as table (must be hash/aos/aoaos/aohos)\n";
    }
}

sub display_output {
    require Perinci::Result::Format::Lite;
    print Perinci::Result::Format::Lite::format(
        $Output, $Opts{output_format});
}

# MAIN

parse_cmdline();
get_input();
$Output = $Input;
display_output();

1;
# ABSTRACT: Manipulate table data
# PODNAME:

=head1 SYNOPSIS

Usage:

 % command-that-outputs-table-data-in-json | td <subcommand> [options ...]

Examples:

 # count number of rows (equivalent to "wc -l" Unix command)
 % osnames -l --json | td rowcount

 # count number of columns
 % osnames -l --json | td colcount

 # remove some columns
 % osnames -l --json | td delcols tags description

 # switch two columns
 % osnames -l --json | td switchcols tags description

 # sort by column(s)
 % osnames -l --json | td sort -value
 % osnames -l --json | td sort value tags

 # add a sum rows, which totals all numeric columns
 % list-files -l --json | td sum

 # add an average rows, which averages all numeric columns
 % list-files -l --json | td avg


=head1 DESCRIPTION

B<EARLY RELEASE. MORE SUBCOMMANDS WILL BE ADDED.>


=head1 OPTIONS


=head1 SEE ALSO

L<TableDef>

=cut
